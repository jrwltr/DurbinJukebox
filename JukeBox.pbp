;=============================================================================
;* JUKEBOX MENU DRUM CONTROLLER
;* JUKE.ASM - Code to run on MC68HC705J1A to control
;* title strip drum and credit/selection lights
;* 1-25-20     J. Walter, translated from assember into PIC Basic
;* 3-14-10     D. Durbin
;*
;=============================================================================
;*
;* Operational Description
;* The STEP UP/DN switches will move the menu drum for easier
;* title strip exchanges when the juke lid is open. Also, the
;* drum will not move via the select switches with the lid open.
;* The PROGRAM switch is used to set the position of the
;* menu drum. When the switch is set, the Program LED will
;* light. At this time the STEP UP and DOWN switches can be
;* used to position the drum so rows 1 & 2 are correctly
;* viewed in the window area with the left most Selection
;* switch pressed in. When the Program switch is turned
;* off, this value is stored in the EEPROM.
;* Then the Program LED is turned off.
;*
;* If programming is required, the STEP switches work as
;* follows.
;*  Pressing the UP switch moves the drum at a slow rate upward
;*   Movement stops when the switch is released.
;*  Pressing the DWN switch moves the drum at a slow rate downward
;*   Movement stops when the switch is released.
;*
;*  ** DO NOT RUN THE DRUM CONTINUOSLY FOR FUN, the position
;*       switches only have fifty thousand rotations of life. The
;*       motor switch turns at 5 times the rate of the drum switch.
;*
;* Normal operation on powerup is to turn on all 4 pricing lights
;* and sequence through the 5 selection lights for 250 msec each.
;* Then lights off. Then the EEPROM data for drum position is read.
;* The value from the EEPROM is used, correct or not. If things
;* appear erratic, follow the setup procedure above.
;* The drum position is checked against the EEPROM position
;* contents and selection switches and adjusted if
;* neccessary.
;*
;* The SPI interface is contained in the Xilinx CPLD. The
;* position switches output a grey code. This is converted
;* to straight binary code inside a pair of EPROMS, so the two
;* position switch registers read as direct binary sequences.
;* These switches are not sync'd mechanically with the drum
;* position, for instance '00h' is not any given drum position.
;* That is why the Program function exists.
;* When a selection switch is pressed, the drum will be rotated
;* in whichever direction is closest to the new switch position.
;*
;* PORTA is the data bus, PA0 is the LSB, PA7 is the MSB
;* Port B is the address and control port
;*                          ; PB0 through PB3 contain the Register address
        REG_SEL_ENB con $10 ; PB4 (acts as a chip select, active high)
        RD_WR_L     con $20 ; PB5 (selects RD - '1' or WR - '0')
;*
;* IRQ_L is an interrupt driven by any change to one of the five menu
;*       select buttons, the top lid openning, the program switch being
;*       set or a step change caused by pressing the up or down buttons.
;*       This is an active low input.
;=============================================================================

CLEAR       ; zero all variables

INCLUDE "ProcessorConfiguration.pbp"

;=============================================================================
REG0_MP     var byte ;storage for data read from Reg 0
    ;* Register 0 - Drum, Motor Position, Read Only
    ;*     Motor position, a 360 degree 7-bit binary readout.
    ;*     This is actually an 8-bit gray code that is converted by
    ;*     EPROM to straight 7-bit binary.
    ;*     Count decreases as the menu drum rolls upward.
    ;*     The count rolls over from 00h to 7Fh.
    ;*     A new two-row section appears with each 360 degree rotation.
    ;*     This is used to position the selected menu section.

;=============================================================================
REG1_DP     var byte ;storage for data read from Reg 1
    ;* Register 1 - Drum, Drum Position, Read Only
    ;*     Menu drum position, a 360 degree 7-bit binary readout.
    ;*     This is actually an 8-bit gray code that is converted by
    ;*     EPROM to straight 7-bit binary.
    ;*     Count increases as the menu drum rolls upward.
    ;*     The count rolls over from 7Fh to 00h.
    ;*     All five menu sections rotate through with each 360 degree rotation.
    ;*     This is used to go to the selected menu section.

;=============================================================================
REG2_SPSW   var byte ;storage for data read from Reg 2
    ;* Register 2 - Selector Switches, Read Only
    ;*     Selector switch inputs.
    ;*     Bits 0 to 4 are mutually exclusive. Active low signals.
    ;*     Bit 0 is menu section 1 (left most switch on the jukebox, rows 1&2)
    ;*     Bit 1 is menu section 2, rows 3&4
    ;*     Bit 2 is menu section 3, rows 5&6
    ;*     Bit 3 is menu section 4, rows 7&8
    ;*     Bit 4 is menu section 5 (right most switch on the jukebox, rows 9&0)
    ;*     Bit 5 is the top lid open signal. Active high.
    ;*     Bit 6 is the EEPROM Program switch. Active low.
    ;*     Bit 7 is the Step Change switch. Active high.
    R2_SELECT_SW_1  con $01
    R2_SELECT_SW_2  con $02
    R2_SELECT_SW_3  con $04
    R2_SELECT_SW_4  con $08
    R2_SELECT_SW_5  con $10
    R2_LID_OPEN     con $20
    R2_PROGRAM_SW   con $40

;=============================================================================
REG3_IM     var byte ;Ram mirror for data written to Reg 3
    ;* Register 3 - Interrupt Mask, Write Only
    ;*     Selector switch input interrupt mask.
    ;*     This register's bits are defined the same as Register 2.
    ;*         However, the complement of REG2 is put in Reg3.
    ;*         The respective bits of each register are exclusive OR'd and
    ;*         AND'd together to drive the interrupt input.
    ;*     Anytime this register's value is the same as register 2, an
    ;*     interrupt will be generated to the CPU.
    ;*     The normal way to use this register is to copy the complemented
    ;*     contents of register 2 into it. This will remove any interrupt. As
    ;*     an input is switched, two input bits will be the same and an interrupt
    ;*     will be generated. Setting register 3 to the complemented value of
    ;*     register 2 will remove the interrupt again.

;=============================================================================
REG4_EESL   var byte ;Ram mirror for data written to Reg 4
    ;* Register 4 - Selector Lights, Write Only
    ;*     Bit 0 is EEPROM command is of short length, (EE_SHORT),'1'= 9-bit, '0'= 25-bit
    ;*     Bit 1 is not used
    ;*     Bit 2 is EEPROM ('1') or DAC ('0') Chip Select (EE_DA_L)
    ;*     Bit 3 is Select Light 1 (for left most switch on the jukebox), Active high.
    ;*     Bit 4 is Select Light 2  Active high.
    ;*     Bit 5 is Select Light 3  Active high.
    ;*     Bit 6 is Select Light 4  Active high.
    ;*     Bit 7 is Select Light 5 (for right most switch on the jukebox), Active high.
    R4_EE_SHORT         con $01
    R4_EE_SELECT        con $04
    R4_CNTRL            con $07
    R4_SELECTOR_LIGHTS  con $f8

;=============================================================================
pricing_switches    var word
up_down_switch      var byte
    UPDWN_NONE  con 0
    UPDWN_UP    con 1
    UPDWN_DWN   con 2
    ;* Register 5 - Pricing Switches, Read Only
    ;*     Pricing switch inputs, '1' = 15 cents, '0' = 10 cents.
    ;*     Bit 0 is row 1
    ;*     Bit 1 is row 2
    ;*     Bit 2 is row 3
    ;*     Bit 3 is row 4
    ;*     Bit 4 is row 5
    ;*     Bit 5 is row 6
    ;*     Bit 6 is row 7
    ;*     Bit 7 is row 8
    ;* Register 6 - Pricing and Programming Switches, Read Only
    ;*     Pricing switch inputs, '1' = 15 cents, '0' = 10 cents.
    ;*     Bit 0 is row 9
    ;*     Bit 1 is row 0
    ;*     Bit 2 is not used, reads a '1'
    ;*     Bit 3 is not used, reads a '1'
    ;*     Bit 4 is not used, reads a '1'
    ;*     Bit 5 is not used, reads a '1'
    ;*     Bit 6 is the Step Up Switch input, STEP_UP_L, active low
    ;*     Bit 7 is the Step Down Switch input, STEP_DOWN_L, active low
    R6_UP_SWITCH    con $40
    R6_DOWN_SWITCH  con $80

;=============================================================================
REG7_PPLD   var byte ;Ram mirror for data written to Reg 7
    ;* Register 7 - Pricing Lights, Programming LED and  , Write Only
    ;*     Bits 7 downto 3 are Selector Light outputs.
    ;*     Bit 0 is the Bottom Row 10 cent light, '1' = ON
    ;*     Bit 1 is the Bottom Row 15 cent light, '1' = ON
    ;*     Bit 2 is the Top Row 10 cent light, '1' = ON
    ;*     Bit 3 is the Top Row 15 cent light, '1' = ON
    ;*     Bit 4 is not used
    ;*     Bit 5 is the Programming LED, active low (PROG_LED_L)
    ;*     Bit 6 is the Menu Drum Enable, active high, (DRUM_ENB)
    ;*     Bit 7 is the Menu Drum Direction, '1' = Down, '0' = Up
    R7_BOTTOM_10    con 1
    R7_BOTTOM_15    con 2
    R7_TOP_10       con 4
    R7_TOP_15       con 8
    R7_ALL_LIGHTS   con $0f
    R7_PROGRAM_LED  con $20
    R7_DRUM_ENABLE  con $40
    R7_DRUM_DOWN    con $80

;=============================================================================
SPI_TX_LO   var byte ;Ram mirror for data written to Reg 8
    ;* Register 8 - SPI TX_LO, write only, low byte of 24-bit
    ;*     transfer to the EEPROM, don't care for DAC

;=============================================================================
SPI_TX_MID  var byte ;Ram mirror for data written to Reg 9
    ;* Register 9 - SPI TX_MID, write only, middle byte of 24-bit
    ;*     transfer to the EEPROM or DAC, this is the high data byte
    ;*     for the EEPROM and the only data byte for the DAC

;=============================================================================
SPI_TX_HI   var byte ;Ram mirror for data written to Reg 10
    ;* Register 10 - SPI TX_HI, write only, high byte of 24-bit
    ;*     transfer to the EEPROM or DAC, this is the command
    ;*     byte for the EEPROM and the DAC
    ;*     ***** NOTE: The start bit for the EEPROM is done in hardware,
    ;*     do not put it in the command register.
    ;*     The command for reading address 32 would be 10110010 (B2)

;=============================================================================
SPI_RX_LO   var byte ;storage for data read from Reg 11
    ;* Register 11 - SPI RX_LO, read only, low byte of 16-bit
    ;*     transfer from the EEPROM

;=============================================================================
SPI_RX_HI   var byte ;storage for data read from Reg 12
    ;* Register 12 - SPI RX_HI, read only, high byte of 16-bit
    ;*     transfer from the EEPROM

;=============================================================================
; SPI Reg 13 has no storage, it is only one bit each way
    ;* Register 13 - SPI CNTL, read/write, Control and Status for
    ;*     the SPI transfer (Reads as 80h after reset)
    ;*     Bit 0 is TRANSFER, writing '1' to this bit starts an SPI transfer.
    ;*     Writing bits 1 to 7 has no effect.
    ;*     Bit 7 is DONE when read, '1' indicates the transfer is complete.
    ;*     Bits 0 to 6 all read as '0'.

;=============================================================================
temp1               var byte ;general storage 1
temp2               var byte ;general storage 2
temp4               var byte ;general storage 4
register_address    var byte ;address of register to be accessed
register_data       var byte ;data written to or read from a register
drum_offset         var byte ;menu drum position offset
motor_offset        var byte ;motor position offset ;motor offset for upward drum movement
program_switch      var bit  ;set non-zero when program switch is enabled
drum_dir_up         var bit  ;set non-zero when drum last moved up, zero when last down
drum_moving         var bit  ;set non-zero when drum is moving
dadac               var byte ;used to store data sent to DAC
drum_position       var byte ;current drum position,0=rows 1&2, 1=rows 3&4,.., 4=rows 9&0
selection_switch    var byte ;current selection switch flag, 0=rows 1&2, .., 4=rows 9&0
spi_bit_count       var byte ;loop count value for SPI transfer completions

;=============================================================================
    PORTB = RD_WR_L

    ;set interrupt mask register
    gosub read_selector_and_program_switches       ;read register 2
    REG3_IM = ~REG2_SPSW
    gosub write_interrupt_mask       ;write complemented reg 2 value to reg 3

    ;set selector lights OFF, EE_SHORT to 25-bit and select EEPROM
    REG4_EESL = R4_EE_SELECT
    gosub write_selector_lights       ;write register 4

    ;set Programming LED and Pricing Lights OFF and drum direction UP
    ; with drum movement disabled
    REG7_PPLD = R7_PROGRAM_LED
    gosub write_pricing_lights

    ;also send FFh to DAC to set its level to zero
    dadac = $FF      ;this stops the motor
    gosub write_dac
    ;SPI interface is already stable

    ;leave all 4 pricing lights on for the duration
    REG7_PPLD = (REG7_PPLD & ~R7_PROGRAM_LED) + R7_ALL_LIGHTS  ;turn on pricing lights and program LED
    gosub write_pricing_lights       ;write pricing lights, program LED

    ;sequence the selection lights for 1/4 second each
    REG4_EESL = (REG4_EESL & R4_CNTRL) | $08
    do
        gosub write_selector_lights
        pause 250
        REG4_EESL = (REG4_EESL & R4_CNTRL) | ((REG4_EESL & R4_SELECTOR_LIGHTS) << 1)
    loop until (REG4_EESL & R4_SELECTOR_LIGHTS) = 0

    ;turn off all lights
    REG7_PPLD = (REG7_PPLD & ~R7_ALL_LIGHTS) | R7_PROGRAM_LED
    gosub write_pricing_lights       ;write pricing lights, program LED and drum control
    REG4_EESL = REG4_EESL & R4_CNTRL
    gosub write_selector_lights       ;turn off selector lights, leave EE control intact

    ;update position offsets from EEPROM
    gosub eeprom_read
    motor_offset = SPI_RX_LO
    drum_offset = SPI_RX_HI

;=============================================================================
mainloop:
;check for lid open as switch functions change when top is raised
    gosub read_selector_and_program_switches     ;check register 2 for open lid
    if (REG2_SPSW & R2_LID_OPEN) then
        ; lid open
        ; up/down step switches work to position drum
        ; program switch works to update position offset values in EEPROM
        gosub read_switches
        if up_down_switch = UPDWN_UP then
            ;step up sw is pressed
            gosub drum_up    ;sets up for upward drum movement
            dadac = $C0     ;this runs the motor at low speed
            gosub write_dac
            drum_moving = 1
        elseif up_down_switch = UPDWN_DWN then
            gosub drum_down   ;sets up for downward drum movement
            dadac = $C0     ;this runs the motor at low speed
            gosub write_dac
            drum_moving = 1
        else
            dadac = $FF     ;this stops the motor
            gosub write_dac
            gosub drum_stop   ;this disables motor select
        endif

        ;done with step switches
        ;check program switch if drum stopped, else bypass
        if drum_moving = 0 then
            gosub read_selector_and_program_switches
            if (REG2_SPSW & R2_PROGRAM_SW) = 0 then
                program_switch = 1
                ;turn on program LED
                REG7_PPLD = REG7_PPLD & ~R7_PROGRAM_LED
                gosub write_pricing_lights
            else
                if program_switch != 0 then
                    program_switch = 0       ;clear progsw flag
                    ;compute motor and drum offsets and write to EEPROM
                    if drum_dir_up = 0 then
                        ;drum was last moving in the downward direction
                        ;compute offset to position motor at 7Fh (downward drum movement)
                        gosub read_motor_position
                        motor_offset = ($7f - REG0_MP + $6) & $7f
                                    ;motor real position ;offset to 7Fh
                                    ;increase value so that stored offset is for upward drum movement
                                    ;zero upper bit
                    else
                        ;drum was last moving in the upward direction
                        ;compute offset to position motor at 7Fh (upward drum movement)
                        gosub read_motor_position
                        motor_offset = $7f - REG0_MP ;subtract motor position from 7Fh to get offset for 7Fh
                    endif
                    gosub read_drum_position        ;compute drum position offset
                    drum_offset = $c - REG1_DP ;offset to center of rows 1&2
                    ;write offsets to EEPROM
                    SPI_TX_LO = motor_offset
                    SPI_TX_MID = drum_offset
                    gosub eeprom_write
                    REG7_PPLD = REG7_PPLD | R7_PROGRAM_LED
                    gosub write_pricing_lights
                endif
            endif
        endif
    else
        ; lid closed
        ;set up lights based on drum position

        ;update pricing switch registers
        gosub read_switches
        ;set lights based on drum position
        gosub read_drum_position
        temp1 = (REG1_DP + drum_offset) & $7f ;now holds current usable drum position
        ;keep in mind usable drum position values will be 0
        ;to 7Fh, all values will be positive
        ;check if drum is in 1-2 range (0h-19h)
        if temp1 <= $19 then
            drum_position = 0 ;currently in rows 1&2 position
        elseif temp1 <= $32 then ;check if drum is in 3-4 range (1Ah-32h)
            drum_position = 1 ;currently in rows 3&4 position
        elseif temp1 <= $4c then ;check if drum is in 5-6 range
            drum_position = 2 ;currently in rows 5&6 position
        elseif temp1 <= $65 then ;check if drum is in 7-8 range
            drum_position = 3 ;currently in rows 7&8 position
        else ;drum must be in 9-0 range
            drum_position = 4 ;currently in rows 9&0 position
        endif

        REG7_PPLD = REG7_PPLD & ~R7_ALL_LIGHTS
        if (pricing_switches & ($1 << (drum_position * 2)) = 0) then ; check top row
            REG7_PPLD = REG7_PPLD | R7_TOP_10
        else
            REG7_PPLD = REG7_PPLD | R7_TOP_15
        endif
        if (pricing_switches & ($2 << (drum_position * 2)) = 0) then ; check bottom row
            REG7_PPLD = REG7_PPLD | R7_BOTTOM_10
        else
            REG7_PPLD = REG7_PPLD | R7_BOTTOM_15
        endif
        gosub write_pricing_lights

        REG4_EESL = (REG4_EESL & R4_CNTRL) | ($8 << drum_position)
        gosub write_selector_lights

        gosub read_selector_and_program_switches
        if (REG2_SPSW & R2_SELECT_SW_1) = 0 then
            ;position switch 1_2 is closed
            selection_switch = 0
        elseif (REG2_SPSW & R2_SELECT_SW_2) = 0 then
            ;position switch 3_4 is closed
            selection_switch = 1
        elseif (REG2_SPSW & R2_SELECT_SW_3) = 0 then
            ;position switch 5_6 is closed
            selection_switch = 2
        elseif (REG2_SPSW & R2_SELECT_SW_4) = 0 then
            ;position switch 7_8 is closed
            selection_switch = 3
        else
            ;position switch 9_0 must be closed
            selection_switch = 4
        endif
        if drum_moving then
            if drum_position = selection_switch then
                gosub ramp_drum_motor_down
                drum_moving = 0
            endif
        else
            ;now check to see if drum is correctly positioned
            if drum_position != selection_switch then
                gosub move_drum
            endif
        endif
    endif
    goto mainloop

;=============================================================================
move_drum  ;this is the major drum movement routine
    ;if drum is already moving return
    if drum_moving then return
    ; select direction - determine which way the drum must rotate
    if drum_position <= selection_switch then
        ; selection switch is greater than drum position
        if (selection_switch - drum_position) < 3 then
            gosub drum_up
        else
            gosub drum_down
        endif
    else
        ; selection switch is less than drum position
        ;   if drum position - selection switch is < 3
        if (drum_position - selection_switch) < 3 then
            gosub drum_down
        else
            gosub drum_up
        endif
    endif

    ;start drum moving
    drum_moving = 1
    ;start ramp_up of motor
    for dadac = $C0 to $60 step -1
        gosub write_dac
        if dadac != $60 then
            pause 8
        endif
    next dadac
    return

;=============================================================================
ramp_drum_motor_down:
    ;ramp down and stop motor
;????    tscr = $00        ;set up RTI for 8msec
    ;determine stop value based on direction
    if drum_dir_up != 0 then
        temp4 = $7F ;drum upward direction ;use temp4 as motor stop value
    else
        temp4 = $05  ;drum downward direction temp4  ;use temp4 as motor stop value
    endif
    temp1 = $60 ;use temp1 for motor speed value
    for temp1 = $68 to $C0 step 8
        dadac = temp1
        gosub write_dac
        ;test for motor position equal to temp1 while slowing motor via RTI
        temp2 = 0       ;use temp2 as flag for twice in row read stop
;????    ckmpi
        gosub read_motor_position
        if ((REG0_MP + motor_offset) & $7f) = temp4 then
            temp2 = temp2 + 1
            if temp2 = 2 then exit
        endif
;????   brclr 6,tscr,ckmpi    ;test for RTI timeout for DAC update
;????   tscr = tscr | $4 ;reset RTI flag
    next temp1
    ;now truly stop motor
    dadac = $ff
    gosub write_dac
    ;disable drive to drum
    gosub drum_stop
    return

;=============================================================================
drum_up:
    drum_dir_up = 1
    REG7_PPLD = (REG7_PPLD & ~R7_DRUM_DOWN) | R7_DRUM_ENABLE ;enable upward drive to drum
    goto write_pricing_lights

;=============================================================================
drum_down:
    drum_dir_up = 0
    REG7_PPLD = REG7_PPLD | (R7_DRUM_ENABLE|R7_DRUM_DOWN) ;enable downward drive to drum
    goto write_pricing_lights

;=============================================================================
drum_stop:
    drum_moving = 0
    REG7_PPLD = (REG7_PPLD & ~(R7_DRUM_ENABLE|R7_DRUM_DOWN)) ;disable drive to drum
    goto write_pricing_lights

;=============================================================================
write_dac:                          ;receives data in register_data
    REG4_EESL = REG4_EESL & R4_SELECTOR_LIGHTS ;selects DAC, leaving select lites intact
    gosub write_selector_lights
    SPI_TX_HI = $03        ;set up to load both channels A & B ;wreg10 is now DAC command register
    gosub write_spi_tx_hi 
    SPI_TX_MID = dadac ;wreg9 is used for DAC data
    gosub write_spi_tx_mid
    spi_bit_count = 16
    gosub spi_start
    return

;=============================================================================
read_register:
    TRISA = $ff ; PORTA all inputs
    PORTB = register_address | RD_WR_L
    PORTB = register_address | REG_SEL_ENB
    pauseus 1 ;give some extra time for data to be valid
    register_data = PORTA ;save register contents in register_data
    PORTB = PORTB & ~REG_SEL_ENB
    return

;=============================================================================
read_motor_position:
    register_address = 0        ;read motor position
    gosub read_register
    REG0_MP = register_data
    return

;=============================================================================
read_drum_position:
    register_address = 1        ;read drum position
    gosub read_register
    REG1_DP = register_data
    return

;=============================================================================
rd2xs var byte ;register used to hold values read the same twice for debounce

read_selector_and_program_switches:
    register_address = 2        ;read selector & program switches
    gosub read_register
    do
        rd2xs = register_data
        pause 50
        gosub read_register
    loop until register_data = rd2xs
    return

;=============================================================================
read_switches:
    register_address = 5
    gosub read_register
    pricing_switches = register_data
    register_address = 6
    gosub read_register
    pricing_switches = pricing_switches | ((register_data & $3) << 8)
    up_down_switch = UPDWN_NONE
    if register_data & R6_UP_SWITCH then
        up_down_switch = UPDWN_UP
    elseif register_data & R6_DOWN_SWITCH then
        up_down_switch = UPDWN_DWN
    endif
    return

;=============================================================================
write_pricing_lights:
    register_address =  7      ;write pricing lights, program LED and drum control sta
    register_data = REG7_PPLD
    goto write_register

;=============================================================================
write_selector_lights:
    register_address = 4 ;write selector lights and EEPROM/DAC control
    register_data = REG4_EESL
    goto write_register

;=============================================================================
write_interrupt_mask:
    register_address = 3
    register_data = REG3_IM
    goto write_register

;=============================================================================
write_spi_tx_lo:
    register_address =  8      ;write SPI_TX_LO register
    register_data = SPI_TX_LO
    goto write_register

;=============================================================================
write_spi_tx_mid:
    register_address =  9      ;write SPI_TX_MID register
    register_data = SPI_TX_MID
    goto write_register

;=============================================================================
write_spi_tx_hi:
    register_address =  10     ;write SPI_TX_HI register
    register_data = SPI_TX_HI
    goto write_register

;=============================================================================
write_register:
    PORTB = register_address & ~RD_WR_L
    PORTB = PORTB | REG_SEL_ENB
    PORTA = register_data ;store data to be put on bus
    TRISA = $00 ; PORTA all outputs
    PORTB = PORTB & ~REG_SEL_ENB
    TRISA = $ff ; PORTA all inputs
    return

;=============================================================================
eeprom_read:
    REG4_EESL = (REG4_EESL & R4_SELECTOR_LIGHTS) | R4_EE_SELECT ;set up to read EEPROM, 25 bit transfer
    gosub write_selector_lights
    SPI_TX_HI = $80        ;set up read EEPROM command for address 00h
    gosub write_spi_tx_hi 
    spi_bit_count = 25
    gosub spi_start   ;starts SPI transfer for read command
    register_address = 12
    gosub read_register
    SPI_RX_HI = register_data
    register_address = 11
    gosub read_register
    SPI_RX_LO = register_data
    return

;=============================================================================
eeprom_write:
    ;Data should already be written in SPI_TX_MID and SPI_TX_LO
    ;SPI_TX_MID contains the Drum offset to be written
    ;SPI_TX_LO contains the Motor offset to be written
    ;send command to enable the EEPROM to be written
    REG4_EESL = (REG4_EESL & R4_SELECTOR_LIGHTS) | (R4_EE_SHORT|R4_EE_SELECT) ;set up to write EEPROM, 9 bit transfer
    gosub write_selector_lights
    SPI_TX_HI = $30 ;set up EEPROM write_enable command
    gosub write_spi_tx_hi      ;write enable command
    spi_bit_count = 9
    gosub spi_start   ;start transfer,send write enable to EEPROM

    REG4_EESL = (REG4_EESL & R4_SELECTOR_LIGHTS) | R4_EE_SELECT ;set up to write EEPROM, 25 bit transfer
    gosub write_selector_lights
    ;SPI_TX_MID must already be valid, set up msbyte data (Drum)
    gosub write_spi_tx_mid
    ;SPI_TX_LO must already be valid, set up lsbyte data (Motor)
    gosub write_spi_tx_lo
    SPI_TX_HI = $40        ;set up write EEPROM command for address 00h
    gosub write_spi_tx_hi 
    spi_bit_count = 25
    gosub spi_start
    pause 15 ;wait for about 15msec, eeprom write should be done by then
    REG4_EESL = (REG4_EESL & R4_SELECTOR_LIGHTS) | (R4_EE_SHORT|R4_EE_SELECT) ;set up to write EEPROM, 9 bit transfer
    gosub write_selector_lights
    SPI_TX_HI = $00         ;set up EEPROM write_disable command
    gosub write_spi_tx_hi 
    ;transfer 9 bits at 0.5usec/bit, use count of 10h
    spi_bit_count = 9
    gosub spi_start   ;send write disable to EEPROM, start transfer
    return

;=============================================================================
spi_start:            ;initiates SPI transfer, assumes registers are set up
    register_address = 13     ;set spi start bit
    register_data = $01
    goto write_register
    pauseus spi_bit_count * 5 ; wait 5 microseconds per bit
    return

;=============================================================================

    End

