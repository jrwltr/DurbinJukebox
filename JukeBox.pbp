;=============================================================================
;* JUKEBOX MENU DRUM CONTROLLER
;* JUKE.ASM - Code to run on MC68HC705J1A to control
;* title strip drum and credit/selection lights
;* 1-25-20     J. Walter, translated from assember into PIC Basic
;* 3-14-10     D. Durbin
;*
;=============================================================================
;*
;* Operational Description
;* The STEP UP/DN switches will move the menu drum for easier
;* title strip exchanges when the juke lid is open. Also, the
;* drum will not move via the select switches with the lid open.
;* The PROGRAM switch is used to set the position of the
;* menu drum. When the switch is set, the Program LED will
;* light. At this time the STEP UP and DOWN switches can be
;* used to position the drum so rows 1 & 2 are correctly
;* viewed in the window area with the left most Selection
;* switch pressed in. When the Program switch is turned
;* off, this value is stored in the EEPROM.
;* Then the Program LED is turned off.
;*
;* If programming is required, the STEP switches work as
;* follows.
;*  Pressing the UP switch moves the drum at a slow rate upward
;*   Movement stops when the switch is released.
;*  Pressing the DWN switch moves the drum at a slow rate downward
;*   Movement stops when the switch is released.
;*
;*  ** DO NOT RUN THE DRUM CONTINUOSLY FOR FUN, the position
;*       switches only have fifty thousand rotations of life. The
;*       motor switch turns at 5 times the rate of the drum switch.
;*
;* Normal operation on powerup is to turn on all 4 pricing lights
;* and sequence through the 5 selection lights for 250 msec each.
;* Then lights off. Then the EEPROM data for drum position is read.
;* The value from the EEPROM is used, correct or not. If things
;* appear erratic, follow the setup procedure above.
;* The drum position is checked against the EEPROM position
;* contents and selection switches and adjusted if
;* neccessary.
;*
;* The SPI interface is contained in the Xilinx CPLD. The
;* position switches output a grey code. This is converted
;* to straight binary code inside a pair of EPROMS, so the two
;* position switch registers read as direct binary sequences.
;* These switches are not sync'd mechanically with the drum
;* position, for instance '00h' is not any given drum position.
;* That is why the Program function exists.
;* When a selection switch is pressed, the drum will be rotated
;* in whichever direction is closest to the new switch position.
;*
;* PORTA is the data bus, PA0 is the LSB, PA7 is the MSB
;* Port B is the address and control port
;*                          ; PB0 through PB3 contain the Register address
        REG_SEL_ENB con $10 ; PB4 (acts as a chip select, active high)
        RD_WR_L     con $20 ; PB5 (selects RD - '1' or WR - '0')
;*
;* IRQ_L is an interrupt driven by any change to one of the five menu
;*       select buttons, the top lid openning, the program switch being
;*       set or a step change caused by pressing the up or down buttons.
;*       This is an active low input.
;=============================================================================

CLEAR       ; zero all variables

INCLUDE "ProcessorConfiguration.pbp"

;=============================================================================
REG0_MP     var byte ;storage for data read from Reg 0
    ;* Register 0 - Drum, Motor Position, Read Only
    ;*     Motor position, a 360 degree 7-bit binary readout.
    ;*     This is actually an 8-bit gray code that is converted by
    ;*     EPROM to straight 7-bit binary.
    ;*     Count decreases as the menu drum rolls upward.
    ;*     The count rolls over from 00h to 7Fh.
    ;*     A new two-row section appears with each 360 degree rotation.
    ;*     This is used to position the selected menu section.

;=============================================================================
REG1_DP     var byte ;storage for data read from Reg 1
    ;* Register 1 - Drum, Drum Position, Read Only
    ;*     Menu drum position, a 360 degree 7-bit binary readout.
    ;*     This is actually an 8-bit gray code that is converted by
    ;*     EPROM to straight 7-bit binary.
    ;*     Count increases as the menu drum rolls upward.
    ;*     The count rolls over from 7Fh to 00h.
    ;*     All five menu sections rotate through with each 360 degree rotation.
    ;*     This is used to go to the selected menu section.

;=============================================================================
REG2_SPSW   var byte ;storage for data read from Reg 2
    ;* Register 2 - Selector Switches, Read Only
    ;*     Selector switch inputs.
    ;*     Bits 0 to 4 are mutually exclusive. Active low signals.
    ;*     Bit 0 is menu section 1 (left most switch on the jukebox, rows 1&2)
    ;*     Bit 1 is menu section 2, rows 3&4
    ;*     Bit 2 is menu section 3, rows 5&6
    ;*     Bit 3 is menu section 4, rows 7&8
    ;*     Bit 4 is menu section 5 (right most switch on the jukebox, rows 9&0)
    ;*     Bit 5 is the top lid open signal. Active high.
    ;*     Bit 6 is the EEPROM Program switch. Active low.
    ;*     Bit 7 is the Step Change switch. Active high.
    R2_SELECT_SW_1  con $01
    R2_SELECT_SW_2  con $02
    R2_SELECT_SW_3  con $04
    R2_SELECT_SW_4  con $08
    R2_SELECT_SW_5  con $10
    R2_LID_OPEN     con $20
    R2_PROGRAM_SW   con $40

;=============================================================================
REG3_IM     var byte ;Ram mirror for data written to Reg 3
    ;* Register 3 - Interrupt Mask, Write Only
    ;*     Selector switch input interrupt mask.
    ;*     This register's bits are defined the same as Register 2.
    ;*         However, the complement of REG2 is put in Reg3.
    ;*         The respective bits of each register are exclusive OR'd and
    ;*         AND'd together to drive the interrupt input.
    ;*     Anytime this register's value is the same as register 2, an
    ;*     interrupt will be generated to the CPU.
    ;*     The normal way to use this register is to copy the complemented
    ;*     contents of register 2 into it. This will remove any interrupt. As
    ;*     an input is switched, two input bits will be the same and an interrupt
    ;*     will be generated. Setting register 3 to the complemented value of
    ;*     register 2 will remove the interrupt again.

;=============================================================================
REG4_EESL   var byte ;Ram mirror for data written to Reg 4
    ;* Register 4 - Selector Lights, Write Only
    ;*     Bit 0 is EEPROM command is of short length, (EE_SHORT),'1'= 9-bit, '0'= 25-bit
    ;*     Bit 1 is not used
    ;*     Bit 2 is EEPROM ('1') or DAC ('0') Chip Select (EE_DA_L)
    ;*     Bit 3 is Select Light 1 (for left most switch on the jukebox), Active high.
    ;*     Bit 4 is Select Light 2  Active high.
    ;*     Bit 5 is Select Light 3  Active high.
    ;*     Bit 6 is Select Light 4  Active high.
    ;*     Bit 7 is Select Light 5 (for right most switch on the jukebox), Active high.
    R4_EE_SHORT         con $01
    R4_EE_SELECT        con $04
    R4_CNTRL            con $07
    R4_SELECTOR_LIGHTS  con $f8

;=============================================================================
pricing_switches    var word
up_down_switch      var byte
    UPDWN_NONE  con 0
    UPDWN_UP    con 1
    UPDWN_DWN   con 2
    ;* Register 5 - Pricing Switches, Read Only
    ;*     Pricing switch inputs, '1' = 15 cents, '0' = 10 cents.
    ;*     Bit 0 is row 1
    ;*     Bit 1 is row 2
    ;*     Bit 2 is row 3
    ;*     Bit 3 is row 4
    ;*     Bit 4 is row 5
    ;*     Bit 5 is row 6
    ;*     Bit 6 is row 7
    ;*     Bit 7 is row 8
    ;* Register 6 - Pricing and Programming Switches, Read Only
    ;*     Pricing switch inputs, '1' = 15 cents, '0' = 10 cents.
    ;*     Bit 0 is row 9
    ;*     Bit 1 is row 0
    ;*     Bit 2 is not used, reads a '1'
    ;*     Bit 3 is not used, reads a '1'
    ;*     Bit 4 is not used, reads a '1'
    ;*     Bit 5 is not used, reads a '1'
    ;*     Bit 6 is the Step Up Switch input, STEP_UP_L, active low
    ;*     Bit 7 is the Step Down Switch input, STEP_DOWN_L, active low
    R6_UP_SWITCH    con $40
    R6_DOWN_SWITCH  con $80

;=============================================================================
REG7_PPLD   var byte ;Ram mirror for data written to Reg 7
    ;* Register 7 - Pricing Lights, Programming LED and  , Write Only
    ;*     Bits 7 downto 3 are Selector Light outputs.
    ;*     Bit 0 is the Bottom Row 10 cent light, '1' = ON
    ;*     Bit 1 is the Bottom Row 15 cent light, '1' = ON
    ;*     Bit 2 is the Top Row 10 cent light, '1' = ON
    ;*     Bit 3 is the Top Row 15 cent light, '1' = ON
    ;*     Bit 4 is not used
    ;*     Bit 5 is the Programming LED, active low (PROG_LED_L)
    ;*     Bit 6 is the Menu Drum Enable, active high, (DRUM_ENB)
    ;*     Bit 7 is the Menu Drum Direction, '1' = Down, '0' = Up
    R7_BOTTOM_10    con 1
    R7_BOTTOM_15    con 2
    R7_TOP_10       con 4
    R7_TOP_15       con 8
    R7_ALL_LIGHTS   con $0f
    R7_PROGRAM_LED  con $20
    R7_DRUM_ENABLE  con $40
    R7_DRUM_DOWN    con $80

;=============================================================================
    ;* Register 8 - SPI TX_LO, write only, low byte of 24-bit
    ;*     transfer to the EEPROM, don't care for DAC

;=============================================================================
    ;* Register 9 - SPI TX_MID, write only, middle byte of 24-bit
    ;*     transfer to the EEPROM or DAC, this is the high data byte
    ;*     for the EEPROM and the only data byte for the DAC

;=============================================================================
    ;* Register 10 - SPI TX_HI, write only, high byte of 24-bit
    ;*     transfer to the EEPROM or DAC, this is the command
    ;*     byte for the EEPROM and the DAC
    ;*     ***** NOTE: The start bit for the EEPROM is done in hardware,
    ;*     do not put it in the command register.
    ;*     The command for reading address 32 would be 10110010 (B2)

;=============================================================================
    ;* Register 11 - SPI RX_LO, read only, low byte of 16-bit
    ;*     transfer from the EEPROM

;=============================================================================
    ;* Register 12 - SPI RX_HI, read only, high byte of 16-bit
    ;*     transfer from the EEPROM

;=============================================================================
    ;* Register 13 - SPI CNTL, read/write, Control and Status for
    ;*     the SPI transfer (Reads as 80h after reset)
    ;*     Bit 0 is TRANSFER, writing '1' to this bit starts an SPI transfer.
    ;*     Writing bits 1 to 7 has no effect.
    ;*     Bit 7 is DONE when read, '1' indicates the transfer is complete.
    ;*     Bits 0 to 6 all read as '0'.

;=============================================================================
register_address    var byte ;address of register to be accessed
register_data       var byte ;data written to or read from a register
drum_offset         var byte ;menu drum position offset
motor_offset        var byte ;motor position offset ;motor offset for upward drum movement
program_switch      var bit  ;set non-zero when program switch is enabled
drum_dir_up         var bit  ;set non-zero when drum last moved up, zero when last down
drum_moving         var bit  ;set non-zero when drum is moving
dac_value           var byte ;used to store data sent to DAC
    DAC_MOTOR_STOP  con $ff
    DAC_MOTOR_SLOW  con $c0
    DAC_MOTOR_FAST  con $60
drum_position       var byte ;current drum position,0=rows 1&2, 1=rows 3&4,.., 4=rows 9&0
selection_switch    var byte ;current selection switch flag, 0=rows 1&2, .., 4=rows 9&0

;=============================================================================
    PORTB = RD_WR_L

    ;set interrupt mask register
    gosub read_selector_and_program_switches
    register_address = 3
    register_data = ~REG2_SPSW
    gosub write_register

    ;set selector lights OFF, EE_SHORT to 25-bit and select EEPROM
    REG4_EESL = R4_EE_SELECT
    gosub write_selector_lights       ;write register 4

    ;set Programming LED and Pricing Lights OFF and drum direction UP
    ; with drum movement disabled
    REG7_PPLD = R7_PROGRAM_LED
    gosub write_pricing_lights

    ;send FFh to DAC to set its level to zero
    dac_value = DAC_MOTOR_STOP
    gosub write_dac

    ;turn on pricing lights and program LED
    REG7_PPLD = (REG7_PPLD & ~R7_PROGRAM_LED) + R7_ALL_LIGHTS
    gosub write_pricing_lights

    ;sequence the selection lights for 1/4 second each
    REG4_EESL = (REG4_EESL & R4_CNTRL) | $08
    do
        gosub write_selector_lights
        pause 250
        REG4_EESL = (REG4_EESL & R4_CNTRL) | ((REG4_EESL & R4_SELECTOR_LIGHTS) << 1)
    loop until (REG4_EESL & R4_SELECTOR_LIGHTS) = 0

    ;turn off all lights
    REG7_PPLD = (REG7_PPLD & ~R7_ALL_LIGHTS) | R7_PROGRAM_LED
    gosub write_pricing_lights
    REG4_EESL = REG4_EESL & R4_CNTRL
    gosub write_selector_lights

    ;update position offsets from EEPROM
    READ 0, motor_offset
    READ 1, drum_offset

;=============================================================================
mainloop:
    gosub read_selector_and_program_switches     ;check register 2 for open lid
    if (REG2_SPSW & R2_LID_OPEN) then
        ; lid open
        ; up/down step switches work to position drum
        ; program switch works to update position offset values in EEPROM
        gosub read_switches
        if up_down_switch = UPDWN_UP then
            gosub drum_up
            dac_value = DAC_MOTOR_SLOW
            gosub write_dac
        elseif up_down_switch = UPDWN_DWN then
            gosub drum_down
            dac_value = DAC_MOTOR_SLOW
            gosub write_dac
        else
            gosub drum_stop
        endif

        ;check program switch if drum stopped, else bypass
        if drum_moving = 0 then
            gosub read_selector_and_program_switches
            if (REG2_SPSW & R2_PROGRAM_SW) = 0 then
                program_switch = 1
                ;turn on program LED
                REG7_PPLD = REG7_PPLD & ~R7_PROGRAM_LED
                gosub write_pricing_lights
            else
                if program_switch != 0 then
                    ; program switch was pressed and now is released
                    program_switch = 0

                    gosub read_motor_position
                    if drum_dir_up then
                        ;drum was last moving in the upward direction
                        motor_offset = $7f - REG0_MP
                    else
                        ;drum was last moving in the downward direction
                        motor_offset = ($7f - REG0_MP + $6) & $7f
                    endif
                    gosub read_drum_position
                    drum_offset = $c - REG1_DP ;offset to center of rows 1&2

                    ;write offsets to EEPROM
                    WRITE  0, motor_offset
                    WRITE  1, drum_offset

                    ; turn off program light
                    REG7_PPLD = REG7_PPLD | R7_PROGRAM_LED
                    gosub write_pricing_lights
                endif
            endif
        endif
    else
        ; lid closed
        gosub read_switches
        gosub read_drum_position
        drum_position = (REG1_DP + drum_offset) & $7f ;now holds current usable drum position
        ;keep in mind usable drum position values will be 0 to 7Fh, all values will be positive
        if drum_position <= $19 then
            drum_position = 0 ;currently in rows 1&2 position
        elseif drum_position <= $32 then ;check if drum is in 3-4 range (1Ah-32h)
            drum_position = 1 ;currently in rows 3&4 position
        elseif drum_position <= $4c then ;check if drum is in 5-6 range
            drum_position = 2 ;currently in rows 5&6 position
        elseif drum_position <= $65 then ;check if drum is in 7-8 range
            drum_position = 3 ;currently in rows 7&8 position
        else ;drum must be in 9-0 range
            drum_position = 4 ;currently in rows 9&0 position
        endif

        ;set up lights based on drum position
        REG7_PPLD = REG7_PPLD & ~R7_ALL_LIGHTS
        if (pricing_switches & (1 << (drum_position * 2)) = 0) then ; check top row
            REG7_PPLD = REG7_PPLD | R7_TOP_10
        else
            REG7_PPLD = REG7_PPLD | R7_TOP_15
        endif
        if (pricing_switches & (2 << (drum_position * 2)) = 0) then ; check bottom row
            REG7_PPLD = REG7_PPLD | R7_BOTTOM_10
        else
            REG7_PPLD = REG7_PPLD | R7_BOTTOM_15
        endif
        gosub write_pricing_lights

        REG4_EESL = (REG4_EESL & R4_CNTRL) | (8 << drum_position)
        gosub write_selector_lights

        gosub read_selector_and_program_switches
        if (REG2_SPSW & R2_SELECT_SW_1) = 0 then
            ;position switch 1_2 is closed
            selection_switch = 0
        elseif (REG2_SPSW & R2_SELECT_SW_2) = 0 then
            ;position switch 3_4 is closed
            selection_switch = 1
        elseif (REG2_SPSW & R2_SELECT_SW_3) = 0 then
            ;position switch 5_6 is closed
            selection_switch = 2
        elseif (REG2_SPSW & R2_SELECT_SW_4) = 0 then
            ;position switch 7_8 is closed
            selection_switch = 3
        else
            ;position switch 9_0 must be closed
            selection_switch = 4
        endif
        if drum_moving then
            if drum_position = selection_switch then
                gosub ramp_drum_motor_down
            endif
        else
            if drum_position != selection_switch then
                gosub ramp_drum_motor_up
            endif
        endif
    endif
    goto mainloop

;=============================================================================
ramp_drum_motor_up:
    if drum_position < selection_switch then
        if (selection_switch - drum_position) < 3 then
            gosub drum_up
        else
            gosub drum_down
        endif
    else
        if (drum_position - selection_switch) < 3 then
            gosub drum_down
        else
            gosub drum_up
        endif
    endif

    ;start ramp_up of motor
    for dac_value = DAC_MOTOR_SLOW to DAC_MOTOR_FAST step -1
        gosub write_dac
        if dac_value != DAC_MOTOR_FAST then
            pause 8
        endif
    next dac_value
    return

;=============================================================================
motor_stop_val  var byte

ramp_drum_motor_down:
    ;ramp down and stop motor
;????    tscr = $00        ;set up RTI for 8msec
    ;determine stop value based on direction
    if drum_dir_up != 0 then
        motor_stop_val = $7F
    else
        motor_stop_val = $05
    endif
    for dac_value = DAC_MOTOR_FAST to DAC_MOTOR_SLOW step 8
        gosub write_dac
temp2               var byte ;general storage 2
        temp2 = 0       ;use temp2 as flag for twice in row read stop
;????    ckmpi
        gosub read_motor_position
        if ((REG0_MP + motor_offset) & $7f) = motor_stop_val then
            temp2 = temp2 + 1
            if temp2 = 2 then exit
        endif
;????   brclr 6,tscr,ckmpi    ;test for RTI timeout for DAC update
    next dac_value
drum_stop:
    dac_value = DAC_MOTOR_STOP
    gosub write_dac
    REG7_PPLD = (REG7_PPLD & ~(R7_DRUM_ENABLE|R7_DRUM_DOWN)) ;disable drive to drum
    goto write_pricing_lights

;=============================================================================
drum_up:
    drum_dir_up = 1
    ; enable upward drive to drum
    REG7_PPLD = (REG7_PPLD & ~R7_DRUM_DOWN) | R7_DRUM_ENABLE
    goto write_pricing_lights

;=============================================================================
drum_down:
    drum_dir_up = 0
    ; enable downward drive to drum
    REG7_PPLD = REG7_PPLD | (R7_DRUM_ENABLE | R7_DRUM_DOWN)
    goto write_pricing_lights

;=============================================================================
write_dac:                          ;receives data in register_data
    REG4_EESL = REG4_EESL & R4_SELECTOR_LIGHTS ;selects DAC, leaving select lites intact
    gosub write_selector_lights

    register_address =  10
    register_data = 3        ;set up to load both channels A & B
    gosub write_register

    register_address =  9
    register_data = dac_value
    gosub write_register

    register_address = 13     ;set spi start bit
    register_data = 1
    goto write_register
    pauseus 16 * 5 ; wait 5 microseconds per bit

    if dac_value = DAC_MOTOR_STOP then
        drum_moving = 0
    else
        drum_moving = 1
    endif
    return

;=============================================================================
read_register:
    TRISA = $ff ; PORTA all inputs
    PORTB = register_address | RD_WR_L
    PORTB = register_address | REG_SEL_ENB
    pauseus 1 ;give some extra time for data to be valid
    register_data = PORTA ;save register contents in register_data
    PORTB = PORTB & ~REG_SEL_ENB
    return

;=============================================================================
read_motor_position:
    register_address = 0
    gosub read_register
    REG0_MP = register_data
    return

;=============================================================================
read_drum_position:
    register_address = 1
    gosub read_register
    REG1_DP = register_data
    return

;=============================================================================
previous_value var byte ;for debounce

read_selector_and_program_switches:
    register_address = 2
    gosub read_register
    do
        previous_value = register_data
        pause 50
        gosub read_register
    loop until register_data = previous_value
    return

;=============================================================================
read_switches:
    register_address = 5
    gosub read_register
    pricing_switches = register_data
    register_address = 6
    gosub read_register
    pricing_switches = pricing_switches | ((register_data & 3) << 8)
    if register_data & R6_UP_SWITCH then
        up_down_switch = UPDWN_UP
    elseif register_data & R6_DOWN_SWITCH then
        up_down_switch = UPDWN_DWN
    else
        up_down_switch = UPDWN_NONE
    endif
    return

;=============================================================================
write_pricing_lights:
    register_address =  7
    register_data = REG7_PPLD
    goto write_register

;=============================================================================
write_selector_lights:
    register_address = 4 ;write selector lights and EEPROM/DAC control
    register_data = REG4_EESL
    goto write_register

;=============================================================================
write_register:
    PORTB = register_address & ~RD_WR_L
    PORTB = PORTB | REG_SEL_ENB
    PORTA = register_data ;store data to be put on bus
    TRISA = $00 ; PORTA all outputs
    PORTB = PORTB & ~REG_SEL_ENB
    TRISA = $ff ; PORTA all inputs
    return

;=============================================================================

    End

